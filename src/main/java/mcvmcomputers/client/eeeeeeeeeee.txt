package mcvmcomputers.client;

import java.io.*;
import java.nio.file.Files;
import java.util.*;
import java.util.zip.*;
import org.apache.commons.lang3.SystemUtils;
import org.lwjgl.glfw.GLFW;
import org.virtualbox_6_1.*;
import mcvmcomputers.*;
import mcvmcomputers.client.entities.render.*;
import mcvmcomputers.client.gui.*;
import mcvmcomputers.client.tablet.TabletOS;
import mcvmcomputers.client.utils.QemuKey;
import mcvmcomputers.entities.*;
import mcvmcomputers.item.OrderableItem;
import mcvmcomputers.networking.PacketList;
import mcvmcomputers.utils.TabletOrder;
import mcvmcomputers.utils.TabletOrder.OrderStatus;
import net.fabricmc.api.ClientModInitializer;
import net.fabricmc.fabric.api.client.rendereregistry.v1.EntityRendererRegistry;
import net.fabricmc.fabric.api.network.ClientSidePacketRegistry;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.texture.*;
import net.minecraft.text.TranslatableText;
import net.minecraft.util.Identifier;

public class ClientMod implements ClientModInitializer {
    public static final OutputStream discardAllBytes = new OutputStream() {
        @Override public void write(int b) {}
    };

    public static boolean qemu = true;
    public static Map<UUID, Identifier> vmScreenTextures = new HashMap<>();
    public static Map<UUID, NativeImage> vmScreenTextureNI = new HashMap<>();
    public static Map<UUID, NativeImageBackedTexture> vmScreenTextureNIBT = new HashMap<>();
    public static EntityItemPreview thePreviewEntity;
    public static boolean vmTurnedOn, vmTurningOff, vmTurningOn;
    public static ISession vmSession;

    public static int maxRam = 8192;
    public static int videoMem = 256;

    public static VirtualBoxManager vbManager;
    public static IVirtualBox vb;
    public static Process vboxWebSrv;
    public static Thread vmUpdateThread;
    public static byte[] vmTextureBytes;
    public static int vmTextureBytesSize;
    public static boolean failedSend;

    public static Process qemuInstance;
    public static ArrayList<QemuKey> qemuKeys = new ArrayList<>();

    public static double mouseLastX, mouseLastY, mouseCurX, mouseCurY;
    public static int mouseDeltaScroll;
    public static boolean leftMouseButton, middleMouseButton, rightMouseButton;
    public static List<Integer> vmKeyboardScancodes = new ArrayList<>();
    public static boolean releaseKeys = false;
    public static boolean isAllowedToRecordKeys = false;
    public static Timer unfocusTimeoutTimer = new Timer();

    public static File vhdDirectory, isoDirectory;
    public static int latestVHDNum = 0;
    public static TabletOS tabletOS;
    public static TabletOrder myOrder;
    public static int vmEntityID = -1;
    public static Thread tabletThread;

    public static float deltaTime;
    public static long lastDeltaTimeTime;

    public static int glfwUnfocusKey1, glfwUnfocusKey2, glfwUnfocusKey3, glfwUnfocusKey4;
    public static String vmSoftwareFolder;

    public static EntityDeliveryChest currentDeliveryChest;
    public static EntityPC currentPC;

    static {
        if (SystemUtils.IS_OS_MAC) {
            glfwUnfocusKey1 = GLFW.GLFW_KEY_LEFT_ALT;
            glfwUnfocusKey2 = GLFW.GLFW_KEY_RIGHT_ALT;
            glfwUnfocusKey3 = GLFW.GLFW_KEY_BACKSPACE;
            glfwUnfocusKey4 = -1;
        } else {
            glfwUnfocusKey1 = GLFW.GLFW_KEY_LEFT_CONTROL;
            glfwUnfocusKey2 = GLFW.GLFW_KEY_RIGHT_CONTROL;
            glfwUnfocusKey3 = GLFW.GLFW_KEY_BACKSPACE;
            glfwUnfocusKey4 = -1;
        }
    }
    public static String getKeyName(int key) {
        return key < 0 ? "None" : glfwKey(key);
    }

    private static String glfwKey(int key) {
        switch (key) {
            case GLFW.GLFW_KEY_LEFT_CONTROL: return "L Control";
            case GLFW.GLFW_KEY_RIGHT_CONTROL: return "R Control";
            case GLFW.GLFW_KEY_LEFT_ALT: return "L Alt";
            case GLFW.GLFW_KEY_RIGHT_ALT: return "R Alt";
            case GLFW.GLFW_KEY_LEFT_SHIFT: return "L Shift";
            case GLFW.GLFW_KEY_RIGHT_SHIFT: return "R Shift";
            case GLFW.GLFW_KEY_ENTER: return "Enter";
            case GLFW.GLFW_KEY_BACKSPACE: return "Backspace";
            case GLFW.GLFW_KEY_CAPS_LOCK: return "Caps Lock";
            case GLFW.GLFW_KEY_TAB: return "Tab";
            default: return GLFW.glfwGetKeyName(key, 0);
        }
    }

    public static ProcessBuilder createQemuProcess(String... commands) {
        if (SystemUtils.IS_OS_WINDOWS) {
            commands[0] = vmSoftwareFolder + File.separator + commands[0] + ".exe";
        }
        return new ProcessBuilder(commands);
    }

    public static void getVHDNum() throws IOException {
        File f = new File(vhdDirectory.getParentFile(), "vhdnum");
        if (f.exists()) {
            latestVHDNum = Integer.parseInt(Files.readAllLines(f.toPath()).get(0));
        }
    }

    public static void increaseVHDNum() throws IOException {
        latestVHDNum++;
        File f = new File(vhdDirectory.getParentFile(), "vhdnum");
        try (FileWriter fw = new FileWriter(f, false)) {
            fw.write(String.valueOf(latestVHDNum));
        }
    }

    public static boolean isQemuRunning() {
        return qemuInstance != null && qemuInstance.isAlive();
    }

    public static void killQemu() {
        try {
            if (qemuInstance != null) {
                qemuInstance.destroyForcibly().waitFor();
            }
        } catch (InterruptedException ignored) {}
        qemuInstance = null;
    }

    public static void startQemu(int cpu, int ram, String vhd, String iso, boolean x64) throws IOException {
        if (isQemuRunning()) killQemu();

        List<String> commands = new ArrayList<>();
        commands.add(x64 ? "qemu-system-x86_64" : "qemu-system-i386");
        commands.add("-vnc");
        commands.add(":1");
        commands.add("-monitor");
        commands.add("telnet:127.0.0.1:55555,server,nowait");
        commands.add("-smp");
        commands.add(String.valueOf(cpu));
        commands.add("-vga");
        commands.add("std");
        commands.add("-m");
        commands.add(String.valueOf(ram));
        commands.add("-enable-kvm");

        if (!vhd.isEmpty()) {
            commands.add("-hda");
            commands.add(new File(vhdDirectory, vhd).getAbsolutePath());
        }

        if (!iso.isEmpty()) {
            commands.add("-cdrom");
            commands.add(new File(isoDirectory, iso).getAbsolutePath());
        }

        ProcessBuilder pb = createQemuProcess(commands.toArray(new String[0]));
        qemuInstance = pb.start();
    }
}
	
	@Override
public void onInitializeClient() {
    MainMod.pcOpenGui = new Runnable() {
        @Override
        public void run() {
            MinecraftClient.getInstance().openScreen(new GuiPCEditing(currentPC));
        }
    };

    MainMod.hardDriveClick = new Runnable() {
        @Override
        public void run() {
            MinecraftClient.getInstance().openScreen(new GuiCreateHarddrive());
        }
    };

    EntityRendererRegistry.INSTANCE.register(EntityList.CRT_SCREEN, CRTScreenRenderer::new);
    EntityRendererRegistry.INSTANCE.register(EntityList.FLATSCREEN, FlatscreenRenderer::new);
    EntityRendererRegistry.INSTANCE.register(EntityList.WALLTV, WallTVRenderer::new);
    EntityRendererRegistry.INSTANCE.register(EntityList.PC, PCRenderer::new);
    EntityRendererRegistry.INSTANCE.register(EntityList.DELIVERY_CHEST, DeliveryChestRenderer::new);
};

		MainMod.hardDriveClick = new Runnable() {
			@Override
			public void run() {
				MinecraftClient.getInstance().openScreen(new GuiCreateHarddrive());
			}
		};
		MainMod.focus = new Runnable() {
			@Override
			public void run() {
				ClientMod.isAllowedToRecordKeys = true;
				MinecraftClient.getInstance().openScreen(new GuiFocus());
			}
		};
		MainMod.deliveryChestSound = new Runnable() {
			@Override
			public void run() {
				if(MinecraftClient.getInstance().getSoundManager().isPlaying(currentDeliveryChest.rocketSound)) {
					MinecraftClient.getInstance().getSoundManager().stop(currentDeliveryChest.rocketSound);
				}
			}
		};
		
		registerClientPackets();
		
		vmScreenTextures = new HashMap<UUID, Identifier>();
		vmScreenTextureNI = new HashMap<UUID, NativeImage>();
		vmScreenTextureNIBT = new HashMap<UUID, NativeImageBackedTexture>();
		
		EntityRendererRegistry.INSTANCE.register(EntityList.ITEM_PREVIEW,
				(entityRenderDispatcher, context) -> new ItemPreviewRender(entityRenderDispatcher));
		EntityRendererRegistry.INSTANCE.register(EntityList.KEYBOARD,
				(entityRenderDispatcher, context) -> new KeyboardRender(entityRenderDispatcher));
		EntityRendererRegistry.INSTANCE.register(EntityList.MOUSE,
				(entityRenderDispatcher, context) -> new MouseRender(entityRenderDispatcher));
		EntityRendererRegistry.INSTANCE.register(EntityList.CRT_SCREEN,
				(entityRenderDispatcher, context) -> new CRTScreenRender(entityRenderDispatcher));
		EntityRendererRegistry.INSTANCE.register(EntityList.FLATSCREEN,
				(entityRenderDispatcher, context) -> new FlatScreenRender(entityRenderDispatcher));
		EntityRendererRegistry.INSTANCE.register(EntityList.WALLTV,
				(entityRenderDispatcher, context) -> new WallTVRender(entityRenderDispatcher));
		EntityRendererRegistry.INSTANCE.register(EntityList.PC,
				(entityRenderDispatcher, context) -> new PCRender(entityRenderDispatcher));
		EntityRendererRegistry.INSTANCE.register(EntityList.DELIVERY_CHEST,
				(entityRenderDispatcher, context) -> new DeliveryChestRender(entityRenderDispatcher));
	}

}

